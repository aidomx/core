{"version":3,"sources":["../src/constants/cacheKey.ts","../src/constants/rulesKey.ts","../src/_maps/events.ts","../src/_maps/ghostElements.ts","../src/security/secureData.ts","../src/_caches/Initializer.ts","../src/utils/deepClone.ts","../src/utils/generateId.ts","../src/utils/logger.ts","../src/utils/normalizeRules.ts","../src/utils/resolvedPath.ts","../src/utils/shallowEqual.ts","../src/security/secureRules.ts","../src/rules/define.ts","../src/rules/store/rupa/actions.ts","../src/rules/store/rupa/index.ts","../src/rules/store/index.ts","../src/constants/ghostId.ts","../src/rules/virtual/actions.ts","../src/rules/virtual/index.ts"],"sourcesContent":["export const CACHE_KEY_RULES = 'CJ1sUcqGXq8OYIBKMLAdft+onbRgu8V2Pze8oW71SH8='\n\nexport const GHOST_ELEMENT_ID = 'ghost-'\nexport const GHOST_KEY_RULES = 'zJ0/GitvAfL5OIuW+Om/QrtU8vRgFncbUcanmRYOFaE='\n\nexport const STORE_KEY_RULES = 'IzfdTfnpiLOcnNuJKH/zFm6nU1gSYooF6teBeYN8jqA='\n","export const RULES_SECRET_KEY =\n  process.env.RULES_SECRET_KEY ?? 'your-secret-key'\n","export const eventMaps = [\n  // Mouse Events\n  'onClick',\n  'onDoubleClick',\n  'onMouseDown',\n  'onMouseUp',\n  'onMouseEnter',\n  'onMouseLeave',\n  'onMouseMove',\n  'onMouseOut',\n  'onMouseOver',\n\n  // Keyboard Events\n  'onKeyDown',\n  'onKeyPress',\n  'onKeyUp',\n\n  // Focus Events\n  'onFocus',\n  'onBlur',\n\n  // Form Events\n  'onChange',\n  'onInput',\n  'onSubmit',\n  'onReset',\n  'onInvalid',\n\n  // Composition Events\n  'onCompositionEnd',\n  'onCompositionStart',\n  'onCompositionUpdate',\n\n  // Drag Events\n  'onDrag',\n  'onDragEnd',\n  'onDragEnter',\n  'onDragExit',\n  'onDragLeave',\n  'onDragOver',\n  'onDragStart',\n  'onDrop',\n\n  // Clipboard Events\n  'onCopy',\n  'onCut',\n  'onPaste',\n\n  // Touch Events\n  'onTouchCancel',\n  'onTouchEnd',\n  'onTouchMove',\n  'onTouchStart',\n\n  // Pointer Events\n  'onPointerDown',\n  'onPointerMove',\n  'onPointerUp',\n  'onPointerCancel',\n  'onPointerEnter',\n  'onPointerLeave',\n  'onPointerOver',\n  'onPointerOut',\n\n  // Media Events\n  'onAbort',\n  'onCanPlay',\n  'onCanPlayThrough',\n  'onDurationChange',\n  'onEmptied',\n  'onEncrypted',\n  'onEnded',\n  'onLoadedData',\n  'onLoadedMetadata',\n  'onLoadStart',\n  'onPause',\n  'onPlay',\n  'onPlaying',\n  'onProgress',\n  'onRateChange',\n  'onSeeked',\n  'onSeeking',\n  'onStalled',\n  'onSuspend',\n  'onTimeUpdate',\n  'onVolumeChange',\n  'onWaiting',\n\n  // Image Events\n  'onError',\n  'onLoad',\n\n  // Animation Events\n  'onAnimationStart',\n  'onAnimationEnd',\n  'onAnimationIteration',\n\n  // Transition Events\n  'onTransitionEnd',\n\n  // UI Events\n  'onScroll',\n  'onResize',\n\n  // Miscellaneous\n  'onContextMenu',\n  'onFocusCapture',\n  'onBlurCapture',\n  'onChangeCapture',\n  'onInputCapture',\n  'onClickCapture',\n  'onSubmitCapture',\n]\n","/**\n * Daftar HTMLElementType\n *\n * Digunakan untuk memvalidasi `design.type` dalam pembuatan ghost component.\n *\n * @type Array<string>\n */\nexport const ghostElements: Array<string> = [\n  // Sections\n  'address',\n  'article',\n  'aside',\n  'footer',\n  'header',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'main',\n  'nav',\n  'section',\n\n  // Grouping content\n  'blockquote',\n  'dd',\n  'div',\n  'dl',\n  'dt',\n  'figcaption',\n  'figure',\n  'hr',\n  'li',\n  'ol',\n  'p',\n  'pre',\n  'ul',\n\n  // Text-level semantics\n  'a',\n  'abbr',\n  'b',\n  'bdi',\n  'bdo',\n  'br',\n  'cite',\n  'code',\n  'data',\n  'dfn',\n  'em',\n  'i',\n  'kbd',\n  'mark',\n  'q',\n  'rb',\n  'rp',\n  'rt',\n  'rtc',\n  'ruby',\n  's',\n  'samp',\n  'small',\n  'span',\n  'strong',\n  'sub',\n  'sup',\n  'time',\n  'u',\n  'var',\n  'wbr',\n\n  // Edits\n  'del',\n  'ins',\n\n  // Embedded content\n  'area',\n  'audio',\n  'img',\n  'map',\n  'track',\n  'video',\n  'iframe',\n  'embed',\n  'object',\n  'param',\n  'picture',\n  'source',\n  'canvas',\n\n  // Forms\n  'form',\n  'input',\n  'textarea',\n  'button',\n  'select',\n  'optgroup',\n  'option',\n  'label',\n  'fieldset',\n  'legend',\n  'datalist',\n  'output',\n  'progress',\n  'meter',\n\n  // Interactive\n  'details',\n  'dialog',\n  'summary',\n\n  // Table\n  'table',\n  'caption',\n  'colgroup',\n  'col',\n  'tbody',\n  'thead',\n  'tfoot',\n  'tr',\n  'td',\n  'th',\n\n  // Web components\n  'slot',\n  'template',\n]\n","import type { DataStore } from '@/types'\n\nexport function encodeData(data: DataStore) {\n  try {\n    const json = JSON.stringify(data)\n    return btoa(encodeURIComponent(json))\n  } catch (error) {\n    console.warn('Failed to encode data:', error)\n    return ''\n  }\n}\n\nexport function decodeData(encoded: string) {\n  try {\n    const json = decodeURIComponent(atob(encoded))\n    return JSON.parse(json)\n  } catch (error) {\n    console.warn('Failed to decode data:', error)\n    return null\n  }\n}\n","import type { CacheRules, DataStore, RuleComponent } from '@/types'\n\n/**\n * rulesMap\n *\n * Digunakan untuk memperbarui seluruh rules.\n */\nexport const rulesMap = new Map<string, CacheRules | any>()\n\n/**\n * ghostMap\n *\n * Spesifik untuk memperbarui rules.compnents\n */\nexport const ghostMap = new Map<string, RuleComponent[]>()\n\n/**\n * storeMap\n *\n * Spesifik untuk memperbarui rules.data\n */\nexport const storeMap = new Map<string, DataStore[]>()\n","export const deepClone = <T>(obj: T): T => JSON.parse(JSON.stringify(obj))\n","export const generateId = (tag: string, index?: number) => {\n  const rand = Math.random().toString(36).substring(2, 5)\n  if (index) {\n    return tag + '_' + index\n  }\n  return tag + '_' + rand\n}\n","export const logWarning = (msg: string) => {\n  if (process.env.NODE_ENV !== 'production') {\n    console.warn(`[WARN]: ${msg}`)\n  }\n}\n","import type { NormalizeRules, RoutesMap } from '@/types'\n\nexport const normalizeRules = (routes: RoutesMap): NormalizeRules[] => {\n  if (Array.isArray(routes)) return routes\n\n  return Object.entries(routes).map(([pathname, name]) => ({\n    pathname,\n    name,\n  }))\n}\n","import type { CacheRules } from '@/types'\nimport { normalizeRules } from './normalizeRules'\n\n/**\n * Check if a component with given `name` is allowed to render\n * based on current `window.location.pathname`, comparing it with\n * `rules.routes` or fallback to `rules.root`.\n *\n * @param name - The name identifier of the component.\n * @param rules - The rules configuration to evaluate against.\n * @returns True if the component is allowed to render, false otherwise.\n */\nexport const resolvedPath = (name: string, rules: CacheRules): boolean => {\n  if (rules?.debug) return true\n\n  if (typeof window !== 'undefined') {\n    const pathname = window.location.pathname\n\n    // Check against rules.routes\n    if (rules?.routes) {\n      if (Array.isArray(rules.routes)) return false\n\n      const routes = normalizeRules(rules.routes)\n      const matchedRoute = routes.some(\n        (route) => route.name.includes(name) && route.pathname === pathname\n      )\n      if (matchedRoute) return true\n    }\n\n    // Check against rules.root\n    if (rules?.root) {\n      if (typeof rules.root === 'string') {\n        return rules.root === pathname\n      }\n      if (Array.isArray(rules.root)) {\n        return rules.root.includes(pathname)\n      }\n    }\n  }\n\n  return false\n}\n","/**\n * Membandingkan dua objek untuk menentukan apakah mereka memiliki nilai yang sama pada properti yang sama.\n * Perbandingan dilakukan hanya pada properti pertama dan tidak menyeluruh ke dalam objek atau array yang lebih dalam.\n *\n * @param prev Objek pertama yang akan dibandingkan\n * @param current Objek kedua yang akan dibandingkan\n * @returns true jika objek `prev` dan `current` memiliki properti yang sama dengan nilai yang sama, false jika tidak\n */\nexport const shallowEqual = <T extends Record<string, any> | null>(\n  prev: T,\n  current: T\n): boolean => {\n  // Jika objek sama persis, return true\n  if (prev === current) return true\n  // Jika salah satu objek null atau undefined, return false\n  if (!prev || !current) return false\n\n  // Ambil daftar kunci dari kedua objek\n  const prevKeys = Object.keys(prev)\n  const currentKeys = Object.keys(current)\n\n  // Jika jumlah kunci berbeda, objek tidak sama\n  if (prevKeys.length !== currentKeys.length) return false\n\n  // Bandingkan nilai untuk setiap kunci\n  for (let key of prevKeys) {\n    if (prev[key] !== current[key]) return false\n  }\n\n  // Semua perbandingan cocok, return true\n  return true\n}\n","import { rulesMap } from '@/_caches'\nimport { CACHE_KEY_RULES } from '@/constants'\nimport { RULES_SECRET_KEY } from '@/constants/rulesKey'\nimport type { Rules, RulesConfig } from '@/types'\nimport { logWarning } from '@/utils'\n\n/**\n * Membekukan dan menyimpan rules ke cacheMap,\n * lalu menginisialisasi jika autorun diaktifkan.\n */\nexport const secureRules = (rules: Rules): Rules => {\n  const secretKey = RULES_SECRET_KEY\n\n  if (!secretKey) {\n    logWarning('RULES_SECRET_KEY is not defined. Rules were not secured.')\n    return {} as Rules\n  }\n\n  const secured = {\n    ...rules,\n    __aidomx__: secretKey,\n  }\n\n  rulesMap.set(CACHE_KEY_RULES, secured)\n  const cached: RulesConfig = rulesMap.get(CACHE_KEY_RULES)\n\n  if (process.env.NODE_ENV === 'production') {\n    return Object.freeze(cached)\n  }\n\n  return cached\n}\n","import { RULES_SECRET_KEY } from '@/constants/rulesKey'\nimport { secureRules } from '@/security'\nimport type { Rules } from '@/types'\n\n/**\n * API publik untuk membuat schema rules.\n *\n * @param rules Schema rules yang ingin digunakan.\n * @returns Hasil dari secureRules (frozen rules atau inisialisasi).\n */\nexport const defineRules = (rules: Rules): ReturnType<typeof secureRules> => {\n  if (!RULES_SECRET_KEY) {\n    throw new Error('RULES_SECRET_KEY is not defined. Cannot define rules.')\n  }\n\n  return secureRules(rules)\n}\n","import { rulesMap, storeMap } from '@/_caches'\nimport { CACHE_KEY_RULES } from '@/constants/cacheKey'\nimport { encodeData } from '@/security'\nimport type {\n  AddStore,\n  RulesConfig,\n  DataStore,\n  DbProps,\n  GetStore,\n  GetStoreProps,\n  RemoveStore,\n  ResetStore,\n  UpdateStore,\n  UpdateStoreProps,\n  DataObject,\n  DbStore,\n} from '@/types'\nimport { deepClone, logWarning } from '@/utils'\n\n/**\n * Membuat kumpulan fungsi aksi untuk mengelola data store berdasarkan pathId dan rules yang diberikan.\n * Digunakan sebagai bagian dari hasil `generateStore()` untuk melakukan operasi seperti add, get, update, remove, dan reset.\n *\n * @param pathId - ID path dari komponen yang akan dimanipulasi.\n * @param rules - Struktur rules yang diambil dari rulesMap, berisi daftar komponen dan datanya.\n * @returns Objek berisi fungsi-fungsi manipulasi data store.\n */\nexport const rupaActions = (pathId: string, rules: RulesConfig) => {\n  /**\n   * Encoded store key based on pathId for isolation and mapping.\n   */\n  const encrypted = encodeData({ id: pathId })\n\n  /**\n   * Ensures that the storeMap entry exists and returns its current state.\n   * Throws error if rules are not available.\n   *\n   * @returns DataStore[] The current data array from the storeMap.\n   */\n  const before = () => {\n    if (!rules) {\n      throw new Error('No rules found in cache.')\n    }\n\n    if (!storeMap.has(encrypted)) {\n      storeMap.set(encrypted, [])\n    }\n\n    return getStoreMap()\n  }\n\n  /**\n   * Syncs the current storeMap data into rulesMap and the component definition.\n   * Skips if the component is not found.\n   */\n  const setRulesMap = async () => {\n    const component = rules.components?.find((c) => c.name === pathId)\n\n    if (!component) {\n      return logWarning(`Component with pathId ${pathId} not found.`)\n    }\n\n    if (!Array.isArray(component.data)) {\n      component.data = []\n    }\n\n    const cloned = getStoreMap()\n    const rules_ = rules.debug ? rules : encodeData(cloned)\n    cloned.map((item) => component.data?.push(deepClone(item)))\n    // component.data.push(cloned)\n    rulesMap.set(CACHE_KEY_RULES, rules_)\n  }\n\n  /**\n   * Retrieves the current storeMap data for the encrypted key.\n   *\n   * @returns DataStore[] The array of current data.\n   */\n  const getStoreMap = () => {\n    const current = storeMap.get(encrypted)\n\n    if (!Array.isArray(current)) {\n      storeMap.set(encrypted, [])\n      return []\n    }\n\n    return current\n  }\n\n  /**\n   * Updates the storeMap with the new data and synchronizes it into rulesMap.\n   *\n   * @param {DataStore[]} lastModified - The array of updated data.\n   * @returns DataStore[] The same updated data after persistence.\n   */\n  const next = async (lastModified: DataStore) => {\n    if (!Array.isArray(lastModified)) {\n      logWarning('next() expects an array of data')\n      return []\n    }\n\n    storeMap.set(encrypted, lastModified)\n    await setRulesMap()\n\n    return lastModified\n  }\n\n  /**\n   * Menambahkan data baru ke komponen tertentu.\n   * Secara otomatis menambahkan ID berdasarkan urutan data terakhir.\n   *\n   * @param data - Objek data yang akan ditambahkan.\n   */\n  const add: AddStore = async (data: DataStore) => {\n    try {\n      const store = before()\n\n      if (!Array.isArray(data)) {\n        return logWarning('Data must be an array when using ctx.add')\n      }\n\n      const prevId = store?.length ?? 0\n      const newData = data.map((item, index) => {\n        let nextId = `${pathId}.${prevId + index + 1}`\n\n        return {\n          id: nextId,\n          ...item,\n        }\n      })\n\n      // Cek dan filter duplikat berdasarkan id\n      const filteredData = newData.filter((item) => {\n        return !store.some((oldData: any) => {\n          return oldData.id === item.id\n        })\n      })\n\n      if (filteredData.length === 0) {\n        return logWarning(`No new data added; all entries already exist.`)\n      }\n\n      return await next(filteredData)\n    } catch (e) {\n      return logWarning(`Failed add data with error : ${(e as Error).message}`)\n    }\n  }\n  /**\n   * Mengambil data dari komponen, dapat difilter berdasarkan kunci tertentu.\n   *\n   * @param props.select - Objek dengan nama properti sebagai kunci dan boolean sebagai penanda apakah properti tersebut diambil.\n   * @returns Data yang difilter sesuai properti yang dipilih atau seluruh rules jika tidak ada `select`.\n   */\n  const get: GetStore = async (options?: GetStoreProps) => {\n    try {\n      const store = before()\n\n      if (!options?.select || Object.keys(options?.select).length === 0) {\n        return getStoreMap() as DataStore\n      }\n\n      const currentData = Array.isArray(store) ? store : []\n\n      const selected = currentData.map((item: DataObject) => {\n        const filtered: Record<string, any> = {}\n        const select: Record<string, boolean> = options.select as DbProps\n\n        for (const key in select) {\n          if (select[key] && key in item) {\n            filtered[key] = item[key]\n          }\n        }\n\n        return filtered\n      })\n\n      return selected\n    } catch (e) {\n      logWarning(`Error getting rules: ${(e as Error).message}`)\n    }\n  }\n\n  /**\n   * Memperbarui data dalam komponen berdasarkan ID dan callback untuk memodifikasi data lama.\n   *\n   * @param id - ID data yang ingin diperbarui.\n   * @param cb - Fungsi callback untuk memodifikasi data sebelumnya.\n   * @returns Promise yang menyelesaikan proses update.\n   */\n  const update: UpdateStore = async (id: string, cb: UpdateStoreProps) => {\n    try {\n      const store = before()\n      const currentData = Array.isArray(store) ? [...store] : []\n      const currentIndex = currentData.findIndex(\n        (item: DbStore) => item.id === id\n      )\n\n      if (currentIndex === -1) {\n        return logWarning(`No data found to update in component ${pathId}.`)\n      }\n\n      const prev = currentData[currentIndex]\n      const next_ = cb(prev)\n\n      currentData[currentIndex] = {\n        ...prev,\n        ...next_,\n      }\n\n      return await next(currentData)\n    } catch (e) {\n      return logWarning(`Update failed with error: ${(e as Error).message}`)\n    }\n  }\n\n  /**\n   * Menghapus data berdasarkan ID dari komponen.\n   * Setelah penghapusan, ID akan diurut ulang secara otomatis.\n   *\n   * @param id - ID data yang ingin dihapus.\n   * @returns Promise yang menyelesaikan proses penghapusan.\n   */\n  const remove: RemoveStore = async (id: string) => {\n    try {\n      const store = before()\n      const currentData = Array.isArray(store) ? [...store] : []\n      const currentIndex = currentData.findIndex(\n        (item: DbStore) => item.id === id\n      )\n\n      currentData.splice(currentIndex, 1)\n      const resetId = currentData.map((item, idx) => {\n        return {\n          ...item,\n          id: `${pathId}.${idx + 1}`,\n        }\n      })\n\n      return await next(resetId)\n    } catch (e) {\n      return logWarning(`Remove item failed because ${(e as Error).message}`)\n    }\n  }\n\n  /**\n   * Mereset semua data dalam komponen ke kondisi kosong.\n   *\n   * @returns Promise yang menyelesaikan proses reset.\n   */\n  const reset: ResetStore = async () => {\n    try {\n      const store = before()\n      if (Array.isArray(store)) {\n        storeMap.clear()\n\n        return store\n      }\n\n      return store\n    } catch (e) {\n      return logWarning(`Reset failed with error: ${(e as Error).message}`)\n    }\n  }\n\n  return {\n    add,\n    get,\n    update,\n    remove,\n    reset,\n  }\n}\n","import { CACHE_KEY_RULES } from '@/constants/cacheKey'\nimport { logWarning, resolvedPath } from '@/utils'\nimport type { RulesConfig, RupaCallback, RupaStore } from '@/types'\nimport { rupaActions } from './actions'\nimport { rulesMap } from '@/_caches'\n\n/**\n * Memanipulasi komponen tertentu di dalam `rules.components`,\n * dengan memberikan akses ke context `RupaStore`.\n *\n * @param path - Nama komponen yang ingin dimanipulasi (harus sesuai dengan `component.name` di rules).\n * @param callback - Fungsi async/sync yang menerima `ctx` sebagai context manipulasi.\n *\n * @example\n * ```ts\n * await rupa(\"HeroSection\", (ctx) => {\n *   ctx.update({ props: { className: \"bg-black\" } })\n * })\n * ```\n *\n * @returns Promise<void>\n *\n * @throws Console warning jika `rules` belum diinisialisasi atau `component` tidak ditemukan.\n */\nclass Rupa {\n  private rules: RulesConfig = rulesMap.get(CACHE_KEY_RULES)\n  private path: string\n  private isRulesValid: boolean = false\n  private callback: RupaCallback\n\n  constructor(path: string, callback: RupaCallback) {\n    this.path = path\n    this.callback = callback\n    this.isRulesValid = this.validateRules()\n    if (this.isRulesValid) {\n      this.initialize()\n    }\n  }\n\n  /**\n   * Prepare for database connection.\n   */\n  public connect(env: any) {\n    console.log('Connecting to environment:', env)\n    return this\n  }\n\n  /**\n   * Initialize and execute callback if validation passed.\n   */\n  private async initialize() {\n    this.guardPathAccess()\n\n    const rupaStore: RupaStore = rupaActions(this.path, this.rules)\n    return await this.callback(rupaStore)\n  }\n\n  /**\n   * Guard access by path.\n   */\n  private guardPathAccess() {\n    const isAllowed = resolvedPath(this.path, this.rules)\n    if (!isAllowed) {\n      throw new Error(`Access to '${this.path}' is not allowed on this route.`)\n    }\n  }\n\n  /**\n   * Validate the loaded rules.\n   */\n  private validateRules(): boolean {\n    if (!this.rules) {\n      logWarning('Rules not initialized. Please defineRules first.')\n      return false\n    }\n\n    if (!this.rules.root || !this.rules.components) {\n      logWarning('Please, set your components rules.')\n      return false\n    }\n\n    if (!this.rules?.components) {\n      logWarning('Ghost components not ready used.')\n      return false\n    }\n\n    const hasComponent = this.rules.components.some((c) => c.name === this.path)\n    if (!hasComponent) {\n      logWarning(`Component '${this.path}' not found.`)\n      return false\n    }\n\n    return true\n  }\n}\n\nexport const rupa = (componentId: string, cb: RupaCallback) =>\n  new Rupa(componentId, cb)\n","import { rulesMap } from '@/_caches'\nimport { CACHE_KEY_RULES } from '@/constants/cacheKey'\nimport type { GenStore, Rules } from '@/types'\nimport { logWarning } from '@/utils'\nimport { rupa } from './rupa'\n\n/**\n * Menghasilkan objek store dasar yang berisi aksi manipulasi store.\n * Store ini bersifat generik dan bertanggung jawab atas add, get, update, remove, dan reset.\n *\n * @returns {GenStore} Store dasar dengan fungsi manipulasi data.\n */\nconst generateStore = (): GenStore => {\n  return { ...{ rupa } }\n}\n\n/**\n * Membuat store jika rules yang diberikan valid dan cocok dengan cache.\n * Digunakan dalam lingkungan runtime setelah rules diamankan.\n *\n * @param {Rules} rules - Rules yang diberikan untuk validasi dan inisialisasi.\n * @returns {GenStore} Store hasil generate jika valid, jika tidak, objek kosong.\n */\nexport const createStore = (rules: Rules): ReturnType<typeof generateStore> => {\n  const isValidRules = validateRules(rules)\n\n  if (!isValidRules) {\n    return {} as GenStore\n  }\n\n  return generateStore()\n}\n\n/**\n * Memvalidasi apakah rules cocok dengan yang disimpan dalam cache.\n * Ini memastikan bahwa hanya rules yang diinisialisasi dengan benar yang akan digunakan untuk store.\n *\n * @param {Rules} rules - Rules yang akan divalidasi terhadap cache.\n * @returns {boolean} True jika valid dan cocok, false jika tidak.\n */\nconst validateRules = (rules: Rules): boolean => {\n  const isReadyRules = rulesMap.has(CACHE_KEY_RULES)\n\n  if (!isReadyRules) {\n    logWarning(\n      'Please, initialize with defineRules before calling createStore.'\n    )\n    return false\n  }\n\n  if (!('__aidomx__' in rules)) {\n    logWarning(\n      'Rules signature is missing. Please use defineRules to initialize rules.'\n    )\n    return false\n  }\n\n  if (!rules.root || !Array.isArray(rules.components)) {\n    logWarning(\n      'Rules structure is invalid. Expected root and components fields.'\n    )\n    return false\n  }\n\n  const cached = rulesMap.get(CACHE_KEY_RULES)\n\n  if (!cached || cached.__aidomx__ !== rules.__aidomx__) {\n    logWarning('Provided rules do not match the cached rules.')\n    return false\n  }\n\n  return true\n}\n","import { encodeData } from '@/security'\nimport { GHOST_ELEMENT_ID } from './cacheKey'\n\nexport const getGhostId = (id: string = 'components') =>\n  encodeData({\n    id: GHOST_ELEMENT_ID + id,\n  })\n","import { ghostMap, rulesMap } from '@/_caches'\nimport { ghostElements } from '@/_maps'\nimport { CACHE_KEY_RULES, GHOST_KEY_RULES } from '@/constants/cacheKey'\nimport { getGhostId } from '@/constants/ghostId'\nimport { encodeData } from '@/security'\nimport type {\n  CreateGhostLayer,\n  RemoveLayer,\n  VirtualApi,\n  RulesConfig,\n  CompileLayer,\n  GhostElement,\n  CreateGhostProps,\n  GhostElements,\n  CloneGhostLayer,\n  SummonGhostLayer,\n  SpawnGhostsLayer,\n  MaintenanceLayer,\n  SpawnConfig,\n  SpawnMapCallback,\n  ResetLayer,\n  RuleComponent,\n  SortGhostLayer,\n  ConnectGhostLayer,\n  RupaManipulator,\n  PushGhostLayer,\n  PullGhostLayer,\n  IsGhostReadyLayer,\n} from '@/types'\nimport { deepClone, generateId, logWarning } from '@/utils'\nimport { createStore } from '../store'\n\nexport const ActionsVirtual = (rules: RulesConfig): VirtualApi => {\n  // @encrypted\n  const encrypted = encodeData(rules)\n\n  let isGhostReady: IsGhostReadyLayer = rulesMap.has(CACHE_KEY_RULES)\n\n  //let isSealed: boolean = false\n\n  //const guarded = <T>(fn: (...args: any[]) => T, fallback: T) => {\n  //return (...args: any[]): T => {\n  //if (isSealed) {\n  //logWarning(\n  //\"If ghost sealed is active, you can't modify ghost components.\"\n  //)\n  //return fallback\n  //}\n\n  //return fn(...args)\n  //}\n  //}\n\n  // @before\n  const before = (id: string = '') => {\n    if (!rules) {\n      throw new Error('No rules found in cache.')\n    }\n\n    const key = getGhostId(id)\n\n    if (!ghostMap.has(key)) {\n      ghostMap.set(key, [])\n    }\n\n    return getGhostMap(key)\n  }\n\n  const connect: ConnectGhostLayer = (\n    fn: (rupa: RupaManipulator) => Promise<void> | void\n  ) => {\n    const ghost = getContainerGhost()\n\n    if (Array.isArray(ghost) && ghost.length > 0) {\n      const { rupa } = createStore(rules)\n\n      return fn(rupa)\n    }\n  }\n\n  // @next\n  const next = (data: GhostElement[] | any[]) => {\n    data.map((ghost) => compile(ghost as GhostElement))\n\n    return data\n  }\n\n  // @getGhostMap\n  const getGhostMap = (key: string = '') => {\n    return ghostMap.get(key) as RuleComponent[]\n  }\n\n  // @getContainerGhost\n  const getContainerGhost = () => {\n    return ghostMap.get(GHOST_KEY_RULES) as RuleComponent[]\n  }\n\n  // @createGhost\n  const createGhost: CreateGhostLayer = (\n    options: CreateGhostProps\n  ): GhostElements => {\n    try {\n      if (!options || !Array.isArray(options.entries)) return []\n\n      const entries = options.entries.map((element) => {\n        const isValid = ghostElements.includes(element.design?.type ?? '')\n\n        if (!isValid) {\n          logWarning(`Tag <${element.design?.type}> is not supported.`)\n        }\n\n        if (options.autoCompile) {\n          compile(element)\n        }\n\n        return element\n      })\n\n      return entries\n    } catch (e) {\n      logWarning(`Failed to create ghost: ${(e as Error).message}`)\n\n      return []\n    }\n  }\n\n  // @compile\n  const compile: CompileLayer = (ghost: GhostElement) => {\n    if (!ghost || !ghost.name || !ghost.design?.type) {\n      logWarning('Invalid ghost element for compilation.')\n      return\n    }\n\n    const cloned = deepClone(ghost)\n    const rules_ = rules.debug ? rules : encrypted\n\n    if (rules?.components) {\n      rules.components.push(cloned)\n    }\n\n    ghostMap.set(getGhostId(ghost.name), [ghost])\n    ghostMap.set(GHOST_KEY_RULES, rules.components ?? [])\n    rulesMap.set(CACHE_KEY_RULES, rules_)\n  }\n\n  // @cloneGhost\n  const cloneGhost: CloneGhostLayer = (id: string) => {\n    before(id)\n    const currentGhost = getContainerGhost()\n\n    const current = currentGhost.find((item) => item.name === id)\n\n    const newData = {\n      ...current,\n      name: id + '_cloned',\n    }\n\n    const cloned = deepClone(newData)\n\n    if (ghostMap.has(id + '_cloned')) {\n      logWarning(`Clone failed because ${id} have already cloned.`)\n      return newData\n    }\n\n    currentGhost.push(cloned ?? current)\n\n    ghostMap.set(id + '_cloned', currentGhost)\n    ghostMap.set(GHOST_KEY_RULES, currentGhost)\n\n    return newData\n  }\n\n  // @sealGhost\n  //const sealGhost: SealGhostLayer = (id: string = '') => {}\n\n  // @summonGhost\n  const summonGhost: SummonGhostLayer = (id: string) => {\n    const ghost = before(id)\n\n    if (!Array.isArray(ghost)) {\n      logWarning(`Ghost component with id ${id} not found`)\n      return []\n    }\n\n    return ghost\n  }\n\n  /**\n   * Spawns multiple ghost components dynamically under a specific ID.\n   *\n   * This function is useful when you want to generate multiple components\n   * programmatically with optional content, styling, and post-processing\n   * via a mapping callback.\n   *\n   * @param {string} id - The unique identifier group to assign the ghost components.\n   * @param {object} config - Configuration object to control how ghosts are spawned.\n   * @param {number} config.count - Total number of ghost components to spawn.\n   * @param {object} config.design - Default design structure applied to each ghost.\n   * @param {string[]} [config.contents] - Optional array of content to assign individually.\n   *   Must match `count` in length if provided.\n   * @param {(ghost: GhostComponent, index: number) => GhostComponent} [config.map] - Optional\n   *   callback to mutate or enhance each ghost before it is finalized.\n   *\n   * @returns GhostComponent[] The array of ghost components that were spawned.\n   * @spawnGhosts\n   */\n  const spawnGhosts: SpawnGhostsLayer = (id: string, config: SpawnConfig) => {\n    const ghost = before(id)\n    const { count, design, contents, map, randomId } = config\n\n    if (Array.isArray(contents) && contents.length === count && !randomId) {\n      for (let i = 0; i < count; i++) {\n        ghost.push({\n          name: generateId(id, i + 1),\n          design: {\n            ...design,\n            content: contents[i],\n          },\n        })\n      }\n\n      return next(withMap(ghost, map))\n    }\n\n    if (contents?.length !== count) {\n      logWarning('Count does not match contents length.')\n      return\n    }\n\n    for (let i = 0; i < count; i++) {\n      ghost.push({\n        name: generateId(id),\n        design: {\n          ...design,\n        },\n      })\n    }\n\n    return next(withMap(ghost, map))\n  }\n\n  // @withMap\n  const withMap = (\n    ghost: GhostElement[],\n    map: SpawnMapCallback | undefined | null\n  ) => {\n    if (typeof map === 'function' && Array.isArray(ghost)) {\n      return ghost.map((g, i) => map(g, i))\n    }\n\n    return ghost\n  }\n\n  const maintenance: MaintenanceLayer = false\n\n  /**\n   * Remove all ghost entries associated with the given component ID.\n   * This will directly update `rules.components` and sync the result to `rulesMap`.\n   *\n   * @param id - The component ID whose ghost entries should be removed.\n   * @returns An empty array representing the cleared ghost data.\n   * @removeGhost\n   */\n  const removeGhost: RemoveLayer = (id: string) => {\n    const ghost = before(id)\n    const currentGhost = getContainerGhost()\n\n    try {\n      if (!Array.isArray(ghost)) {\n        logWarning(`Ghost component with id ${id} not found.`)\n        return false\n      }\n\n      const deleteGhost = ghostMap.delete(getGhostId(id))\n\n      if (deleteGhost) {\n        const index = currentGhost.findIndex((c) => c.name === id)\n        currentGhost?.splice(index as number, 1)\n        rules.components = currentGhost\n\n        ghostMap.set(GHOST_KEY_RULES, currentGhost)\n        rulesMap.set(CACHE_KEY_RULES, rules.debug ? rules : encrypted)\n\n        return true\n      }\n\n      return false\n    } catch (e) {\n      logWarning(\n        `Failed delete component with id ${id} because with error : ${(e as Error).message}`\n      )\n      return false\n    }\n  }\n\n  // @resetGhost\n  const resetGhost: ResetLayer = () => {\n    rulesMap.clear()\n    ghostMap.clear()\n\n    rules.components = []\n\n    rulesMap.set(CACHE_KEY_RULES, rules.debug ? rules : encrypted)\n\n    return true\n  }\n\n  // @pushGhost\n  const pushGhost: PushGhostLayer = (): RulesConfig => {\n    try {\n      if (!isGhostReady) {\n        logWarning('Please, setup your rules.')\n        return {} as RulesConfig\n      }\n\n      const rules_ = rulesMap.get(CACHE_KEY_RULES)\n\n      if (!rules_?.root || !rules_?.components) {\n        logWarning('Invalid rules, rules is not ready used.')\n        return {} as RulesConfig\n      }\n\n      if (!Array.isArray(rules_.components)) {\n        logWarning(\n          'Rules successfully, but ghost components is not ready used.'\n        )\n        return {} as RulesConfig\n      }\n\n      return rules_\n    } catch (e) {\n      logWarning(`Push rules is failed with error : ${(e as Error).message}`)\n\n      return {} as RulesConfig\n    }\n  }\n\n  // @pullGhost\n  const pullGhost: PullGhostLayer = (): Record<string, GhostElement> => {\n    // const isGhostReady = ghostMap.has(GHOST_KEY_RULES)\n\n    if (!isGhostReady) {\n      logWarning('Ghost components is not ready used.')\n      return {}\n    }\n\n    const ghost = getContainerGhost()\n\n    return groupByName(ghost)\n  }\n\n  const groupByName = (ghosts: GhostElement[]) => {\n    const result: Record<string, GhostElement> = {}\n\n    for (const item of ghosts) {\n      if (item?.name) {\n        result[item.name] = item\n      }\n    }\n\n    return result\n  }\n\n  // @sortGhost\n  const sortGhost: SortGhostLayer = (config: {\n    from?: string\n    to?: string\n  }) => {\n    const ghost = getContainerGhost()\n\n    const fromIndex = ghost.findIndex((g) => g.name === config.from)\n    const toIndex = ghost.findIndex((g) => g.name === config.to)\n\n    if ((fromIndex === -1 && toIndex === -1) || config.from === config.to) {\n      return ghost // nothing to do\n    }\n\n    const [fromItem] = ghost.splice(fromIndex, 1)\n\n    const actualToIndex = toIndex > fromIndex ? toIndex - 1 : toIndex\n    ghost.splice(actualToIndex + 1, 0, fromItem)\n\n    //const sorted: typeof ghost = []\n\n    //ghost.forEach((g) => {\n    //if (g.name === config.posBefore && config.posBefore) {\n    //sorted.push(g)\n    //const toMove = ghost.filter((x) => x.name === id)\n    //sorted.push(...toMove)\n    //} else if (g.name === config.posAfter && config.posAfter) {\n    //const toMove = ghost.filter((x) => x.name === id)\n    //sorted.push(g, ...toMove)\n    //} else if (g.name !== id) {\n    //sorted.push(g)\n    //}\n    //})\n\n    return next(ghost)\n  }\n\n  return {\n    createGhost,\n    connect,\n    cloneGhost,\n    isGhostReady,\n    //sealGhost,\n    summonGhost,\n    spawnGhosts,\n    maintenance,\n    removeGhost,\n    resetGhost,\n    pullGhost,\n    pushGhost,\n    sortGhost,\n  }\n}\n","import { rulesMap } from '@/_caches'\nimport { CACHE_KEY_RULES } from '@/constants/cacheKey'\nimport type { Rules, VirtualApi } from '@/types'\nimport { logWarning } from '@/utils'\nimport { ActionsVirtual } from './actions'\n\nconst generateVirtual = (): VirtualApi => {\n  const cached = rulesMap.get(CACHE_KEY_RULES)\n\n  return { ...ActionsVirtual(cached) }\n}\n\nexport const createVirtual = (\n  rules: Rules\n): ReturnType<typeof generateVirtual> => {\n  const isValidRules = validateRules(rules)\n\n  if (!isValidRules) {\n    return {} as VirtualApi\n  }\n\n  return generateVirtual()\n}\n\nconst validateRules = (rules: Rules): boolean => {\n  const isReadyRules = rulesMap.has(CACHE_KEY_RULES)\n\n  if (!isReadyRules) {\n    logWarning(\n      'Please, initialize with defineRules before calling createStore.'\n    )\n    return false\n  }\n\n  if (!('__aidomx__' in rules)) {\n    logWarning(\n      'Rules signature is missing. Please use defineRules to initialize rules.'\n    )\n    return false\n  }\n\n  if (!rules.root || !Array.isArray(rules.components)) {\n    logWarning(\n      'Rules structure is invalid. Expected root and components fields.'\n    )\n    return false\n  }\n\n  const cacheRules = rulesMap.get(CACHE_KEY_RULES)\n\n  if (!cacheRules || cacheRules.__aidomx__ !== rules.__aidomx__) {\n    logWarning('Provided rules do not match the cached rules.')\n    return false\n  }\n\n  return true\n}\n"],"mappings":"ubAAO,IAAMA,EAAkB,+CAElBC,EAAmB,SACnBC,EAAkB,+CAElBC,GAAkB,+CCL/B,IAAAC,EAAaC,GACXD,EAAA,QAAQ,IAAI,mBAAZ,KAAAA,EAAgC,kBCD3B,IAAME,GAAY,CAEvB,UACA,gBACA,cACA,YACA,eACA,eACA,cACA,aACA,cAGA,YACA,aACA,UAGA,UACA,SAGA,WACA,UACA,WACA,UACA,YAGA,mBACA,qBACA,sBAGA,SACA,YACA,cACA,aACA,cACA,aACA,cACA,SAGA,SACA,QACA,UAGA,gBACA,aACA,cACA,eAGA,gBACA,gBACA,cACA,kBACA,iBACA,iBACA,gBACA,eAGA,UACA,YACA,mBACA,mBACA,YACA,cACA,UACA,eACA,mBACA,cACA,UACA,SACA,YACA,aACA,eACA,WACA,YACA,YACA,YACA,eACA,iBACA,YAGA,UACA,SAGA,mBACA,iBACA,uBAGA,kBAGA,WACA,WAGA,gBACA,iBACA,gBACA,kBACA,iBACA,iBACA,iBACF,ECzGO,IAAMC,EAA+B,CAE1C,UACA,UACA,QACA,SACA,SACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,MACA,UAGA,aACA,KACA,MACA,KACA,KACA,aACA,SACA,KACA,KACA,KACA,IACA,MACA,KAGA,IACA,OACA,IACA,MACA,MACA,KACA,OACA,OACA,OACA,MACA,KACA,IACA,MACA,OACA,IACA,KACA,KACA,KACA,MACA,OACA,IACA,OACA,QACA,OACA,SACA,MACA,MACA,OACA,IACA,MACA,MAGA,MACA,MAGA,OACA,QACA,MACA,MACA,QACA,QACA,SACA,QACA,SACA,QACA,UACA,SACA,SAGA,OACA,QACA,WACA,SACA,SACA,WACA,SACA,QACA,WACA,SACA,WACA,SACA,WACA,QAGA,UACA,SACA,UAGA,QACA,UACA,WACA,MACA,QACA,QACA,QACA,KACA,KACA,KAGA,OACA,UACF,EC7HO,SAASC,EAAWC,EAAiB,CAC1C,GAAI,CACF,IAAMC,EAAO,KAAK,UAAUD,CAAI,EAChC,OAAO,KAAK,mBAAmB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","names":["CACHE_KEY_RULES","GHOST_ELEMENT_ID","GHOST_KEY_RULES","STORE_KEY_RULES","_a","RULES_SECRET_KEY","eventMaps","ghostElements","encodeData","data","json","error","decodeData","encoded","rulesMap","ghostMap","storeMap","deepClone","obj","generateId","tag","index","rand","logWarning","msg","normalizeRules","routes","pathname","name","resolvedPath","name","rules","pathname","normalizeRules","route","shallowEqual","prev","current","prevKeys","currentKeys","key","secureRules","rules","secretKey","RULES_SECRET_KEY","logWarning","secured","__spreadProps","__spreadValues","rulesMap","CACHE_KEY_RULES","cached","defineRules","rules","RULES_SECRET_KEY","secureRules","rupaActions","pathId","rules","encrypted","encodeData","before","storeMap","getStoreMap","setRulesMap","_a","component","c","logWarning","cloned","rules_","item","deepClone","rulesMap","CACHE_KEY_RULES","current","next","lastModified","data","store","prevId","filteredData","index","nextId","__spreadValues","oldData","e","options","filtered","select","key","id","cb","currentData","currentIndex","prev","next_","resetId","idx","__spreadProps","Rupa","path","callback","rulesMap","CACHE_KEY_RULES","env","rupaStore","rupaActions","resolvedPath","_a","logWarning","c","rupa","componentId","cb","generateStore","rupa","createStore","rules","validateRules","rulesMap","CACHE_KEY_RULES","logWarning","cached","getGhostId","id","encodeData","GHOST_ELEMENT_ID","ActionsVirtual","rules","encrypted","encodeData","isGhostReady","rulesMap","CACHE_KEY_RULES","before","id","key","getGhostId","ghostMap","getGhostMap","connect","fn","ghost","getContainerGhost","rupa","createStore","next","data","compile","GHOST_KEY_RULES","createGhost","options","element","_a","_b","_c","ghostElements","logWarning","e","cloned","deepClone","rules_","cloneGhost","currentGhost","current","item","newData","__spreadProps","__spreadValues","summonGhost","spawnGhosts","config","count","design","contents","map","randomId","i","generateId","withMap","g","maintenance","removeGhost","index","c","resetGhost","pushGhost","pullGhost","groupByName","ghosts","result","fromIndex","toIndex","fromItem","actualToIndex","generateVirtual","cached","rulesMap","CACHE_KEY_RULES","__spreadValues","ActionsVirtual","createVirtual","rules","validateRules","logWarning","cacheRules"]}